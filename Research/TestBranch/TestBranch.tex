%% <+Last Edited: Thu 13 Feb 2014 23:20:55 GMT by seblovett on seblovett-Ubuntu +>
\documentclass[12pt,a4paper]{article}
%\usepackage[nodayofweek]{datetime}
%\usepackage{natbib}
\usepackage{listings}
\usepackage{bibunits}
\title{ELEC6025: VLSI Design Project \\Part 1: Microprocessor Research\\Topic: Test and Branch}
\author{Henry Lovett\\ Team: R4\\Course Tutor: Mr B. Iain McNally}
\date{\today}
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\clearpage
\begin{bibunit}
\section{Introduction}
%A short introduction to the material presented in this report \dots\citep{greenwade93}

This report details the research done for the ``Test and Branch'' part of team R4 for the VLSI design module (ELEC6027).
It looks into 2 aspects of processor design - condition codes and conditional branches. 
The report begins with a overview of what should be achieved by the condition codes and branches. 
Three case studies of some simple architectures are then discussed, looking into how they work and includes code snippets. 
Some honourable mentions of other architectures are discussed also. 
The report then finishes with a comparison of the case studies and discusses the conclusions that can be drawn from this research
The authors' recommendation for the implementation is also given in this section.

One or more sections covering your research topic.
Here you should include appropriate figures and code snippets to illustrate your discussion. Ensure that all figures and code snippets are properly explained in your text.
Where text, figures or code snippets are copied from another source, the source must be clearly acknowledged. Copied text must be surrounded by quotation marks "..." to show clearly that it is copied. 

\section{Operation}
What is the point in flags and branches. Why do we need them.

\section{Case studies}

Three case studies are discussed here. 
For each architecture studied, there is a description of the flags implemented (if any) and instructions used for conditional branches. 
Also, two C code snippets, seen in listings \ref{ListC} and \ref{ListC2}, are converted to assembler for each architecture to see how they compare.
\begin{lstlisting}[frame=single,caption=C Code,language=C,label=ListC]
uint16_t a = 0;
for(uint16_t i = 0; i < 10; i++)
{
	a = a + i;
}
\end{lstlisting}
\begin{lstlisting}[frame=single,caption=C Code,language=C,label=ListC2]
if ( a > 0 )
	b = 1;
else
	b = 0;
\end{lstlisting}
\subsection{ARM Cortex M0}

The ARM Cortex M0 is a 32-bit RISC architecture that implements the Thumb/Thumb2 instruction set \citep{ARM:CortexM0}. 
It implements 19 formats of instructions in total, one of which is the `conditional branch' instruction. 
The conditional branch instruction depends on the value in the status register from a previous operation.

\subsubsection{Flags}
The Cortex M0 uses 4 flags; Carry, oVerflow, Zero and Negative \citep{ARM:Flags}. 
The flags are stored in a specific register, the Application Program Status Register (APSR). 
The APSR is updated by a number of instructions. 
All arithmetic instructions have the ability to update the register depending on the result of the arithmetic operation. 
This can be seen in the assembler by an {\textit `S'} suffix to the instruction.
This optional update is only in the Thumb2 instruction set, not the Thumb.
In the Thumb instruction set, all ALU operations update the status register.

There are also four instructions which update the status register - Compare (CMP), Compare Negative (CMN), Test Bits (TST) and Test Equivalence (TEQ).
These can all be part of an ALU instruction, or an immediate instruction \citep{ARM:CMPCMN}.
Compare subtracts the register value from the other operand, and CMN is the same, but negates the second operand.
These two instructions update all the flags, but discard the result of the operation.
TST performs an AND function between the two operands. 
This is the same as an AND instruction, but only affects the Z and N flags.
Similarly, there exists a TEQ instruction which conducts and XOR between the two operands and only updates the Z and N flags \citep{ARM:TSTTEQ}.
The TST and TEQ instructions do not store the result of the operation.


\subsubsection{Conditional Execution}
%ARM also supports conditional execution, however this is not including in the Thumb instruction set (but is in the Thumb2 instruction set).
Thumb2 has support for conditional execution.
This is where operations are only executed if the condition code in the instruction matches up with the value in the status register.
In total, there are 15 condition codes \citep{ARM:conditioncodes} and are similar to the conditional branch options, discussed in section \ref{arm:conditionalbranch}.
This is particularly useful in a pipelined processor for small if-else clauses as no flushing / stalling needs to be done, as the execution of the instruction is done, but the result isn't stored.
A small drop in performance is seen, but this isn't as bad as flushing a deep pipeline.

In the Thumb instruction set, the lack of these condition codes is replaced by the use of the conditional branches.
In an if-else clause, there must be one conditional branch, and one unconditional branch.
Thumb does not implement the condition execution due to it being a 16-bit instruction set - Thumb2 is 32-bit.


\begin{table}
\centering
\begin{tabular}{ccc}\hline
Flag & Shorthand & Explanation \\ \hline
Carry & C & \\
Overflow & V & \\
Zero & Z & Set if the ALU result \\
Negative & N & Set if the ALU result is less than 0, i.e. bit 7 is set high. \\
\end{tabular}
\caption{Explanation of the flags in the ARM Cortex M0}
\end{table}
\subsubsection{Conditional Branch}\label{arm:conditionalbranch}

The Thumb instruction set has a conditional branch instruction.
This is capable of incrementing the program counter by an immediate value, depending on the flags in the status register.
Fourteen different conditions are supported, and the full list can be seen in \cite{ARM:Thumb}.
They include individual flag tests, as well as both signed and unsigned greater/less than tests.
The value of the flags is from the last instruction that set the flags - in Thumb2, this is the last instruction with an {\textit 'S'} suffix.
If the branch is decided to be taken, then the program counter is incremented by the immediate value.

In Thumb2, the conditional execution can be used on a branch instruction to conditionally alter the value in the program counter.

\subsubsection{Assembler Examples}
Below are snippets of assembly language for the Cortex M0 to implement the C code seen in listings \ref{ListC} and \ref{ListC2}.
Here, the advantage of the conditional execution can be seen.
In a small if-else clause, it only takes three instructions, and no branches.
This speeds up the processor, as conditional branches can be costly.
They will work very well in a pipelined processor, as well as a non-pipelined processor.

\begin{lstlisting}[frame=single,caption=Thumb/Thumb2 Assembler for code in listing \ref{ListC},label=ARM1]
.def a=$r1
.def i=$r2
MOV a #0 ;load a with 0
MOV i #0 ;load i with 0
loop:
CMP i #10 ;compare i to 10.
BEQ exit ;branch if i == 10
ADDNE a a i ; a = a + i if i != 10
ADDNE i i #1 ; i++ if i != 10
BNE loop ; jump to loop if i != 10
exit: 
...
\end{lstlisting}


\begin{lstlisting}[frame=single,caption=Thumb/Thumb2 Assembler for code in listing \ref{ListC2},label=ARM2]
.def a $r1
.def b $r3
CMP a #0 ; compare a to 0
MOVEQ b #1 ; if a == 0, load b with 1
MOVENE b #0 ; if a != 0, load b with 0
\end{lstlisting}


\subsection{Intel 8086}

The 8086 is a 16 bit microprocessor released in 1978.
This was the original processor designed by Intel.
Is is a CISC based architecture and implements the original x86 instruction set.
Since then, the x86 instruction set has been expanded and the original instructions are still implemented in the lasted Intel CPUs.

\subsubsection{Flags}

The Intel 8086 has 9 flags, detailed in table \ref{tab:Intel:flags}.
The status register is updated when a compare (\texttt{CMP, CMPSB, CMPSW}) instruction is executed, or after an arithmetic operation.


\begin{table}
\centering
\caption{Intel 8086 Flags from \cite{Intel:flags}}
\label{tab:Intel:flags}
\begin{tabular}{ccc} \hline
Flag & Shorthand & Explanation \\ \hline
Carry & C & Carry from the 8 bit arithmetic \\
Zero & Z & Set if the result of the ALU is zero \\
Sign & S & Set to the most significant bit of the ALU result \\
Overflow & O & Set on two's complement overflow \\
Parity & P & 1 if the ALU result is even parity, 0 if odd \citep{flag:p} \\
Auxiliary (or Adjust) & A & The carry generated from the low 4 bits of the ALU operation \citep{flag:a}\\
Trap & T & Used for single step debugging \citep{flag:t} \\
Direction & D & Sets the source index to increment / decrement (0/1) \citep{flag:d} \\
Interrupt & I & Enables / disables interrupts \citep{flag:i} \\
\end{tabular}
\end{table}

\subsubsection{Conditional Branch}

The 8086 has a total of 31 conditional branch instructions, and one jump instruction \citep{Intel:instructionset}.
The conditional branches cover many different logic combinations between 5 flags - C, Z, O, S and P.
This enables the 8086 to make signed and unsigned decisions.
The full set of branch instructions can be seen at \cite{Intel:condjumps}.

In the assembly language, there are multiple instructions that map to the same instruction.
For example, the \texttt{JE} instruction checks that the \texttt{Z} flag is set, but the \texttt{JZ} instruction also does this.
It can be seen that this is to make the code more readable as the instructions actually map to the same machine code \cite{Intel:datasheet}.
In total, therefore, there are 17 actual instructions.

The 8086 also implements a \texttt{LOOP} instruction.
This is linked to a specific register (usually the \texttt{CX} register) and will branch if the value of \texttt{CX} does not become $0$ after being decremented.
There is another instruction, \texttt{LOOPE / LOOPZ}, that jumps if the counter is zero, and the zero flag is set. 
This has a complementary instruction, \texttt{LOOPNE / LOOPNZ}, which jumps if the counter is nonzero and the zero flag is not set.
These instructions are useful, as it combines the decrement of a counter with a branch, resulting in a quicker operation for loops.


\subsubsection{Assembler Example}


\subsection{MIPS}
\subsubsection{Flags}
\subsubsection{Conditional Branch}
\subsubsection{Assembler Example}


\section{Other Architectures}
\subsection{DEC Alpha}
\subsection{AVR}
Even though the AVR is a microcontroller core, it still posed interesting reading. 

T Flag
\section{Conclusion}
Here I would like you to discuss how the issues raised in your report will affect your processor design. Where you have seen different processors opting for different solutions to the same problem you should discuss their relative merits in the context of your design. 

\putbib[references]
\end{bibunit}
%References - reading referenced in text
%\bibliographystyle{plain}
%\bibliography{references}
%%Biliography - all the reading done
%\renewcommand{\refname}{Bibliography}
%\nocite{*}
%\bibliography{bibliography}
%\begin{thebibliography}{9}
%\bibitem{test} ARM Example, 1992
%
%\end{thebibliography}
\end{document}
