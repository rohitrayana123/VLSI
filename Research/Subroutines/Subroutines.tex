\documentclass[12pt,a4paper]{article}
\usepackage{listings}
\usepackage{color}
\usepackage{url}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[nodayofweek]{datetime}
\usepackage{natbib}




\title{ELEC6027: VLSI Design Project \\Part 1: Microprocessor Research\\Topic: Subroutines}
\author{Ashley Robinson\\ Team: R4\\Course Tutor: Mr B. Iain McNally}
\date{\today}
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\clearpage

\lstset{
   frame=L,
   basicstyle=\footnotesize,        % the size of the fonts that are used for the code
   captionpos=b
}


\section{Introduction}

Subroutines, also known as procedures, methods, functions or just routines, are smaller sections of code inside larger program designed to perform certain tasks which is described in~\cite{alison}.
The motivation for subroutines is to produce code which is more efficient in size, easy to adapt and above all else maintain. 
They help form the foundations of third generation programming languages.

Designing hardware such that it is capable of executing subroutines only requires available memory and access to the program counter.
Designing hardware to call and return from subroutines efficiently can vastly improve the performance of a processor. 


\section{Research}

\subsection{Subroutine Context Save }
Context save allows a microprocessor to switch execution focus but retain data such that the previous focus can be fully restored.
Using call and return instructions when running a subroutine may automatically save context, usually the program counter, but may also require additional instructions to guarantee safe execution.
Nested and recursive subroutines, introduced in~\cite{IainPrograms}, require dealing with multiple context saves while retaining the data for all previous calls. 
The Intel 8086, discussed further in section~\ref{8086}, has support for procedure call instructions which automatically use the stack to organise data.
Listing~\ref{lst:factorial.c} holds subroutine written in C that recursively calls itself to compute the factorial of a number.
Such applications require context save support.

\lstinputlisting[label=lst:factorial.c,frame=single,caption=Factorial subroutine]{Code/factorial.c}


A stack, as discussed in~\cite{stack}, is a Last-In-First-Out (LIFO) data structure which is used as store when the immediately accessible registers do not provide enough memory.
The stack can be thought of to grow in size where a register called a \emph{stack pointer} (SP) holds the address of the top most element in main memory.
Two operations can be performed on the stack; \emph{push}, which adds an item to the stack and increments the stack pointer, together with \emph{pull}, which performs the reverse therefore shrinking the stack. 
It is convention for the stack to occupy the main memory and grow down from the top address towards memmory allocated for other purposes; this can be seen in figure~\ref{fig:allocation}.


\begin{figure}[htb]
   \centering
   \includegraphics[height=5cm]{Figures/allocation.pdf}
   \caption{Allocation of the stack in main memory. Based on a MIPS architecture adapted from~\cite{stack}.}
   \label{fig:allocation}
\end{figure}






\subsection{Operation of Stack Frames}

\subsubsection{8086}
\label{8086}
The assembly held in listing~\ref{lst:8086Caller.asm} and~\ref{lst:8086Callee.asm} is written for the Intel 8086 microprocessor.
A basic example of how stack frames are built to pass parameters to and from a subroutine.
The main program in listing~\ref{lst:8086Caller.asm} loads two immediate values into registers then begins building a stack frame by pushing them to the stack.  
The subroutine is called to act upon the arguments passed via the stack.
When control is passed back to these set of instructions and the return value is extracted by using relative addressing from the base pointer then finally two stack pops completely destroy the stack frame.

\lstinputlisting[label=lst:8086Caller.asm,frame=single,caption=8086Caller.asm]{Code/8086Caller.asm}



When the subroutine, in listing~\ref{lst:8086Callee.asm}, is called the return address is pushed onto the stack.
This built-in support for the stack handles branching and next line address storage using a call function.
To start the base pointer is placed on the stack so stack pointer has value to which to be restored.
Reducing the value of the stack pointer allocates space for local variables.
The first argument is placed in memory as local variable; this is unnecessary but serves as example.
The second argument is loaded into a working register.
The first local variable is added to the working register which is then placed in to the memory for the second local variable.
Finally the stack pointer and the base pointer are restored and a return instruction hands control over the caller. 
This is all part of the calling convention for subroutines using stack frames on the 8086~\cite{8086call}.
 
\lstinputlisting[label=lst:8086Callee.asm,frame=single,caption=8086Callee.asm]{Code/8086Callee.asm}



This code was tested upon an 8086 emulator~\cite{emu8086}.
The emulator provides a complete overview of the flow of data within the processor including the stack. 
Figure~\ref{fig:emu} shows the emulator during the execution of the subroutine just before the stack pointer is overwritten with the base pointer.
Figure~\ref{fig:stack} is an abstraction of the stack with data label corresponding to the subroutine. 

\begin{figure}[htb]
        \centering
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[height=5cm]{Figures/emu.png}
                \caption{Emulator registers and stack}
                \label{fig:emu}
        \end{subfigure}%
        \begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[height=5cm]{Figures/stack.pdf}
                \caption{Stack frame configuration}
                \label{fig:stack}
        \end{subfigure}
        \caption{8086 stack operation}
        \label{fig:8086}
\end{figure}







\subsubsection{ARM7TDMI using Arm Thumb}
The ARM7TDMI is a 32-bit RISC microprocessor with an emphasis on low-power design and pipelining for high throughput~\cite{ARM7TDMI}.
It has two instruction sets. One of which is Arm Thumb, a low density 16-bit subset of the ARM assembly language~\cite{arm}.
A user selectable flag is set to switch between instruction sets therefore drawing on each sets advantages.
The advantage, explained in~\cite{ARMs}, is a reduction in code density. 

This architecture does not have built-in support for calling subroutines using the stack.
When the branch instruction is used, as seen in listing~\ref{lst:ArmCaller.asm}, the program counter is overwritten with the address of the corresponding label.
The address of the next line of code, which should be returned to after the subroutine, is placed into the link register.
Calling conventions suggests leaving this register untouched and simply moving the data back into the program counter on a return.
\lstinputlisting[label=lst:ArmCaller.asm,frame=single,caption=ArmCaller.asm]{Code/ArmCaller.asm}

In this case the link register is pushed onto the stack from the subroutine therefore requiring the subroutine to pop the value into the program counter in order to return.
Listing~\ref{lst:ArmCallee.asm} holds the subroutine and handles placing the return address on the stack.
Relative addressing on the stack is required to draw the two arguments out and replace the first with the output of the function.
\lstinputlisting[label=lst:ArmCallee.asm,frame=single,caption=ArmCallee.asm]{Code/ArmCallee.asm}






\section{Conclusion}

It is clear that whether a microprocessor has built-in support for a stack or not the ability to call subroutines is unaffected.
The support does make calling more efficient and easier to code. 


%References - reading referenced in text
\bibliographystyle{plain}
\bibliography{references}
%Biliography - all the reading done
\renewcommand{\refname}{Bibliography}
\begin{thebibliography}{9}

\bibitem{Patterson}
  Patterson D A and Hennessy J L,
  \emph{Computer Organisation and Design: The Hardware/Software Interface}.
  Morgan Kaufman,
  4th Edition,
  2009.\\
  - Lots of processor concepts and MIPS examples

\bibitem{Mathur}
  Mathur S,
  \emph{Microprocessor 8086: Architecture, Programming and Interfacing}.
  PHI Learning Private Limited,
  2011.\\
  - Intel 8086 microprocessor resource


\end{thebibliography}
\end{document}
