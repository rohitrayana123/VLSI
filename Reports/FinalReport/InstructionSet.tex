%  InstructionSet.tex
%  Document created by seblovett on seblovett-Ubuntu
%  Date created: Thu 17 Apr 2014 14:54:27 BST
%  <+Last Edited: Thu 17 Apr 2014 17:34:32 BST by seblovett on seblovett-Ubuntu +>

\chapter{Instruction Set}
\incomplete{Instruction Set}
\todo[color=cyan, inline]{Design of instruction set (Started)}
%\todo[color=cyan, inline]{Allocation of opcodes etc}
\todo[color=cyan, inline]{Refer to research (yes, but not sourced)}
\todo[color=cyan, inline]{ISA novelties (some integrated, no dedicated section)}

In designing the instruction set architecture (ISA) emphasis was put on creating a complete set of basic operations which could be used to implement any program. This gave rise to a RISC based architecture since they have a small number of instructions and are optimized for a smaller chip area. They also promote a simpler datapath since the same length instructions can be bit-sliced into more identical slices. Irregular lengths will cause common fields to be in a different location within the instruction, leading to more complex decoding and potential wasted hardware when executing shorter instructions. 
\todo[inline]{Expand basic ISA design considerations}

Since a 16-bit microprocessor was to be designed, it was decided to base the system on the ARM Thumb architecture. This is a subset of the main 32-bit ARM instruction set which contains a suitably complete set of instructions. However it included a number of operations which take advantage of the ARM's 32-bit datapath, so any high register operations were removed. Change of state, sign extension and debugging instructions, among others, were also removed for simplification or because they were not necessary. This produced the original ISA made up of instructions 1-4, 6-10, 12-16, 20-24, 27-32, 35 and 36 as noted in the summary table in Appendix~\ref{chap:AppISS}. While instructions 5 and 11 were added to support use of carry flag with an immediate value. 17, 18 and 19 are included to form a complete logic set. 25 and 26 are for loading an initial value to any general purpose register. Instruction 33 is included from the SPARC ISA for returning from a procedure. Instruction 34 enables a control jump to anywhere in $2^{16}$ memory locations. While instructions 37-41 were added for support of a single interrupt.

Within this ISA it was decided to support up to 3 operands. This allows greater flexibility with the instructions available and reduces the amount of memory required to perform data processing operations. The number of instructions and their groupings determined the requirement of having 6-bits for the Opcode field. As such, 8 internal registers could be used since it is a realistic number for a RISC system and can be referenced in the remaining 10 bits. With the option of expanding the third operand to a 5 bit immediate value. This benefits from how common it is that a small immediate value is used more than a larger one. There was also support added for byte sized operations with two operand formatting since this is a standard length for small binary values. 

An important aspect of ISA design is the consideration of how much memory is required to store a particular program. An architecture which requires less space will be desirable since more information can be stored in the same amount of memory. To achieve this a high code density if required. However RISC systems have a lower density than CISC, because the latter is capable of operations such as automatic context saving within the same instruction for performing a procedure call. The density of this system has been improved by using 3 operand instructions to reduce the number of data transfers required. This is illustrated in Figure~\ref{fig:NoOperands} in terms of register transfers required to add two register values and place the result in another register. 

\begin{figure}[h]
\setlength{\tabcolsep}{2pt}
\centering
\footnotesize
\begin{tabular}{l|rcl|}
	\cline{2-4}
	3 Operands & R1 & $\leftarrow$ & R2 + R3 \\
	\cline{2-4}
	\multirow{2}{*}{2 Operands} & R1 & $\leftarrow$ & R2 \\
	 & R1 & $\leftarrow$ & R1 + R3 \\
	\cline{2-4}
	\multirow{3}{*}{1 Operand} & Acc & $\leftarrow$ & R2 \\
	 & ~Acc & $\leftarrow$ & Acc + R3 \hspace{0.5cm} \\
	 & R1 & $\leftarrow$ & Acc \\
	\cline{2-4}
\end{tabular}
\caption{Comparison of Operand Amounts}
\label{fig:NoOperands}
\end{figure}

Both control transfer and interrupt operations, with one exception, do not use any registers. This meant the free space could be used for further definitions, leaving only one opcode being needed for each. A 3-bit condition field allows a sufficient quantity of branching operations to be supported, leaving 8 bits to define the distance to move forwards or backwards. However since there is a limitation on the distance, it was deemed necessary to include the instruction ``JMP'' which takes a register address for transferring to any position in memory. 

\newcolumntype{B}{c}
\begin{table}[h]
\def\arraystretch{1.5}
\centering
\footnotesize
\setlength{\tabcolsep}{2.5pt}
\makebox[\linewidth]{
\begin{tabular}{|r|l|l||BBBBBBBBBBBBBBBc|}
	 \multicolumn{1}{r}{} & \multicolumn{1}{l}{\bf Instruction Type} & \multicolumn{1}{l}{\bf Sub-Type} & 15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & \multicolumn{1}{B}{0} \\
	\hline
	A1 & \multirow{2}{*}{\bf Data Manipulation} & {\bf Register} & \multicolumn{5}{B|}{\multirow{2}{*}{Opcode}} & \multicolumn{3}{B|}{\multirow{2}{*}{Rd}} & \multicolumn{3}{B|}{\multirow{2}{*}{Ra}} & \multicolumn{3}{B|}{Rb} & X & X \\
	\cline{1-1} \cline{3-3} \cline{15-19}
	A2 &  & {\bf Immediate} & \multicolumn{5}{B|}{} & \multicolumn{3}{B|}{} & \multicolumn{3}{B|}{} & \multicolumn{5}{B|}{imm4/5} \\
	\hline
	B & \multicolumn{2}{l||}{\bf Byte Immediate} & \multicolumn{5}{B|}{Opcode} & \multicolumn{3}{B|}{Rd} & \multicolumn{8}{B|}{imm8} \\
	\hline
	C & \multicolumn{2}{l||}{\bf Data Transfer} & 0 & \multicolumn{1}{|B|}{LS} & 0 & 0 & \multicolumn{1}{B|}{0} & \multicolumn{3}{B|}{Rd}  &\multicolumn{3}{B|}{Ra} & \multicolumn{5}{B|}{imm5} \\
	\hline
	D1 & \multirow{2}{*}{\bf Control Transfer} & {\bf Others} & \multirow{2}{*}{1} & \multirow{2}{*}{1} & \multirow{2}{*}{1} & \multirow{2}{*}{1} & \multicolumn{1}{B|}{\multirow{2}{*}{0}} & \multicolumn{3}{B|}{\multirow{2}{*}{Cond.}}  & \multicolumn{8}{B|}{imm8} \\
	\cline{1-1} \cline{3-3} \cline{12-19}
	D2 &  & {\bf Jump} &  &  &  &  & \multicolumn{1}{B|}{} & & & \multicolumn{1}{B|}{ } & \multicolumn{3}{B|}{Ra} & \multicolumn{5}{B|}{imm5} \\
	\hline
	E & \multicolumn{2}{l||}{\bf Stack Operations} & 0 & \multicolumn{1}{|B|}{U} & 0 & 0 & \multicolumn{1}{B|}{1} & \multicolumn{1}{B|}{L} & X & \multicolumn{1}{B|}{X} & \multicolumn{3}{B|}{Ra} & 0 & 0 & 0 & 0 & \multicolumn{1}{B|}{1} \\
	\hline
	F & \multicolumn{2}{l||}{\bf Interrupts} & 1 & 1 & 0 & 0 & \multicolumn{1}{B|}{1} & \multicolumn{3}{B|}{ICond.} & 1 & 1 & \multicolumn{1}{B|}{1} & X & X & X & X & \multicolumn{1}{B|}{X} \\
	\hline
\end{tabular}
}
\caption{General Instruction Formatting}
\label{tab:GIF}
\end{table}

The concept of orthogonality in instruction formatting involves the separation of bits into different fields which can each be assigned a value independently. Where each field defines a different aspect of the instruction. To promote orthogonality, the instruction formatting for data manipulation operations followed a similar structure to the ARM Thumb, as shown in Table~\ref{tab:GIF}. Which was adapted to create all other types of formatting, and reordered to ensure immediate values were always on the far right of the instruction. This was to make sign extension of immediate values in the datapath easier since they are always in the same location in the instruction. It was also necessary to align all the destination and source registers to maintain consistency between instructions, aiding datapath simplicity. 

Allocation of opcodes was done using k-map design with the arrangement designated according to the operation needing to be performed within the ALU module. This was because this allocation would have the greatest effect on the amount of logic needed for the ALU decoder. With the resultant mapping shown in Table~\ref{tab:OpKmapA} and Table~\ref{tab:OpKmapB}, with the important groupings highlighting. The four groupings shown correspond to command signals from decoder to ALU which need to be active for more than one instruction. 

\todo[inline]{Possibly combine Opcode kmap tables into subfigures?}
%counter for counting nodes needed for circling
\newcounter{nodecount}
%Command for making new node and naming according to counter
\newcommand\tabnode[1]{\addtocounter{nodecount}{1} \tikz \node (\arabic{nodecount}) {#1};}

% Some options common to all the nodes and paths
\tikzstyle{every picture}+=[remember picture,baseline]
\tikzstyle{every node}+=[inner sep=0pt,anchor=base,
minimum width=1.2cm,align=center,text depth=.25ex,outer sep=1.5pt]
\tikzstyle{every path}+=[thick, rounded corners]

%custom colouring
\newcommand{\darkercolor}[3]{% Reference Color, Percentage, New Color Name
    \colorlet{#3}{#1!#2!black}
}
\darkercolor{green}{60}{darkgreen}

\begin{table}[h!]
\begin{minipage}[b]{1 \linewidth}
\def\arraystretch{1.5}
\centering
\footnotesize
	\begin{tabular}{l|c|c|c|c|l}
		\multicolumn{1}{l}{} & \multicolumn{1}{c}{00} & \multicolumn{1}{c}{01} & \multicolumn{1}{c}{11} & \multicolumn{1}{c}{10} \\
		\cline{2-5}
		000 & \tabnode{LDW} & \tabnode{STW} & \tabnode{NOP} & \tabnode{AND} & \\  
		001 & \tabnode{POP} & \tabnode{PUSH} & \tabnode{`F'} & \tabnode{OR} & \\
		011 & \tabnode{ADDIB} & \tabnode{SUBIB} & \tabnode{\cellcolor{gray}} & \tabnode{XOR} & \\
		010 & \tabnode{ADD} & \tabnode{SUB} & \tabnode{NEG} & \tabnode{NOT} & \\
		110 & \tabnode{ADDI} & \tabnode{SUBI} & \tabnode{`D'} & \tabnode{NAND} & \\
		111 & \tabnode{CMP} & \tabnode{CMPI} & \tabnode{LSL} & \tabnode{NOR} & \\
		101 & \tabnode{ADCI} & \tabnode{SUBI} & \tabnode{LSR} & \tabnode{LLI} & \textcolor{blue}{$\bullet$ FAOut} \\
		100 & \tabnode{ADC} & \tabnode{SUC} & \tabnode{ASR} & \tabnode{LUI} & \textcolor{red}{$\bullet$ ShOut}\\
		\cline{2-5}
	\end{tabular}
	\caption{Opcode Assignment K-Map A}
	\label{tab:OpKmapA}
\end{minipage}
\begin{minipage}[b]{1 \linewidth}
\def\arraystretch{1.5}
\centering
\footnotesize
	\begin{tabular}{l|c|c|c|c|l}
		\multicolumn{1}{l}{} & \multicolumn{1}{c}{00} & \multicolumn{1}{c}{01} & \multicolumn{1}{c}{11} & \multicolumn{1}{c}{10} \\
		\cline{2-5}
		000 & \tabnode{LDW} & \tabnode{STW} & \tabnode{NOP} & \tabnode{AND} & \\  
		001 & \tabnode{POP} & \tabnode{PUSH} & \tabnode{`F'} & \tabnode{OR} & \\
		011 & \tabnode{ADDIB} & \tabnode{SUBIB} & \tabnode{\cellcolor{gray}} & \tabnode{XOR} & \\
		010 & \tabnode{ADD} & \tabnode{SUB} & \tabnode{NEG} & \tabnode{NOT} & \\
		110 & \tabnode{ADDI} & \tabnode{SUBI} & \tabnode{`D'} & \tabnode{NAND} & \\
		111 & \tabnode{CMP} & \tabnode{CMPI} & \tabnode{LSL} & \tabnode{NOR} & \phantom{\textcolor{blue}{$\bullet$ FAOut}} \\
		101 & \tabnode{ADCI} & \tabnode{SUBI} & \tabnode{LSR} & \tabnode{LLI} & \textcolor{darkgreen}{$\bullet$ SUB} \\
		100 & \tabnode{ADC} & \tabnode{SUC} & \tabnode{ASR} & \tabnode{LUI} & \textcolor{orange}{$\bullet$ ShR} \\
		\cline{2-5}
	\end{tabular}
	\caption{Opcode Assignment K-Map B}
	\label{tab:OpKmapB}
\end{minipage}

\begin{tikzpicture}[overlay]
	%Define path of circles
	\draw [blue](1.north west) -- (2.north east) -- (30.south east) -- (29.south west) -- cycle;
	\draw [blue](14.north west) -- (15.north east) -- (19.south east) -- (18.south west) -- cycle;
	\draw [red](3.north west) -- (3.north east) -- (7.south east) -- (7.south west) -- cycle;
	\draw [red](23.north west) -- (23.north east) -- (27.south east) -- (27.south west) -- cycle;
	\draw [red](27.north west) -- (28.north east) -- (32.south east) -- (31.south west) -- cycle;
	\draw [darkgreen](38.north west) -- (38.north east) -- (42.south east) -- (42.south west) -- cycle;
	\draw [darkgreen](50.north west) -- (50.north east) -- (62.south east) -- (62.south west) -- cycle;
	\draw [darkgreen](46.north west) -- (47.north east) -- (47.south east) -- (46.south west) -- cycle;
	\draw [darkgreen](53.north west) -- (54.north east) -- (54.south east) -- (53.south west) -- cycle;
	\draw [orange](59.north west) -- (59.north east) -- (63.south east) -- (63.south west) -- cycle;
\end{tikzpicture}
\end{table}

Allocation of Condition codes for control transfer instructions was based upon the type and action of each branch. The aspects considered were: conditional or unconditional, use of link register and flags used. These are summarised in Table~\ref{tab:CondAssign}a. From this, the first bit was set according to whether there was a condition to be checked. Then the second bit was set if the unconditional instruction used the link register, or the conditional instruction checked the zero flag. Since interrupts are only used in the controller, and added as they were deemed necessary, there is no specific ordering to the operations. As shown in Table~\ref{tab:CondAssign}b. 

\begin{table}[h!]
\def\arraystretch{1.2}
\centering
\footnotesize
\subfloat[Cond. Assignment]{%
	\hspace{.5cm}
	\begin{tabular}{l|cccc|c|}
		\multicolumn{1}{c}{} & \multicolumn{1}{c}{Un} & \multicolumn{1}{c}{LR} & \multicolumn{1}{c}{Z} & \multicolumn{1}{c}{N,V} & \multicolumn{1}{c}{Cond.} \\
		\cline{2-6}
		BR  & \ding{51} & \ding{55} & \ding{55} & \ding{55} & 000 \\
		BNE & \ding{55} & \ding{55} & \ding{51} & \ding{55} & 110 \\
		BE  & \ding{55} & \ding{55} & \ding{51} & \ding{55} & 111 \\
		BLT & \ding{55} & \ding{55} & \ding{55} & \ding{51} & 100 \\
		BGE & \ding{55} & \ding{55} & \ding{55} & \ding{51} & 101 \\
		BWL & \ding{51} & \ding{51} & \ding{55} & \ding{55} & 011 \\
		RET & \ding{51} & \ding{51} & \ding{55} & \ding{55} & 010 \\
		JMP & \ding{51} & \ding{55} & \ding{55} & \ding{55} & 001 \\
		\cline{2-6}
	\end{tabular}
	\hspace{.5cm}
}
\subfloat[ICond. Assignment]{ %
	\hspace{.5cm}
	\begin{tabular}{l|c|}
		\multicolumn{1}{l}{ } & \multicolumn{1}{c}{ICond.} \\
		\cline{2-2}
		RETI & 000 \\
		ENAI & 001 \\
		DISI & 010 \\
		STF  & 011 \\
		LDF  & 100 \\
		\cline{2-2}
	\end{tabular}
	\hspace{.5cm}
}
\caption{Condition Code Assignments}
\label{tab:CondAssign}
\end{table}