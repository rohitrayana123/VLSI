%  InstructionSet.tex
%  Date created: Thu 27 Mar 2014 10:12:34 GMT

\section{Instruction Set}

This chapter describes the full set of instructions implemented by the architecture. Each instruction is divided into one of 6 groups:
\begin{itemize}
	\item Data Manipulation
	\item Byte Immediate
	\item Data Transfer
	\item Control Transfer
	\item Stack Operations
	\item Interrupt Operations
\end{itemize}
These follow a general formatting as follows:

\newcolumntype{B}{>{\begin{varwidth}{0.1cm}} c <{\end{varwidth}}} %M is for Maximal column

\begin{table}[h]
\centering
\begin{tabular}{|r|l|l|BBBBBBBBBBBBBBBc|}
	 \multicolumn{1}{r}{} & \multicolumn{1}{l}{Instruction Type} & \multicolumn{1}{l}{Sub-Type} & 15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & \multicolumn{1}{B}{0} \\
	\hline
	A1 & \multirow{2}{*}{\bf Data Manipulation} & {\bf Register} & \multicolumn{5}{c|}{Opcode} & \multicolumn{3}{c|}{Rd} & \multicolumn{3}{c|}{Ra} & \multicolumn{3}{c|}{Rb} & X & X \\
	\cline{1-1} \cline{3-19}
	A2 &  & {\bf Immediate} & \multicolumn{5}{c|}{Opcode} & \multicolumn{3}{c|}{Rd} & \multicolumn{3}{c|}{Ra} & \multicolumn{5}{c|}{imm4/5} \\
	\hline
	B & \multicolumn{2}{l|}{\bf Byte Immediate} & \multicolumn{5}{c|}{Opcode} & \multicolumn{3}{c|}{Rd} & \multicolumn{8}{c|}{imm8} \\
	\hline
	C & \multicolumn{2}{l|}{\bf Data Transfer} & 0 & \multicolumn{1}{|c|}{LS} & 0 & 0 & \multicolumn{1}{c|}{0} & \multicolumn{3}{c|}{Rd}  &\multicolumn{3}{c|}{Ra} & \multicolumn{5}{c|}{imm5} \\
	\hline
	D1 & \multirow{2}{*}{\bf Control Transfer} & \multicolumn{1}{l|}{\bf Others} & 1 & 1 & 1 & 1 & \multicolumn{1}{c|}{0} & \multicolumn{3}{c|}{\multirow{2}{*}{Cond.}}  & \multicolumn{8}{c|}{imm8} \\
	\cline{1-1} \cline{3-8} \cline{12-19}
	D2 &  & \multicolumn{1}{l|}{\bf Jump} & 1 & 1 & 1 & 1 & \multicolumn{1}{c|}{0} & & & \multicolumn{1}{c|}{ } & \multicolumn{3}{c|}{Ra} & \multicolumn{5}{c|}{imm5} \\
	\hline
\end{tabular}
\end{table}

%
% Instructions 1-8
%
\Imnemonic{Add Word}{ADD}
\Iformat{A}{00010}
\Isyntax{ADD Rd, Ra, Rb}{ADD R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra + Rb$}{C}{V}{b}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Ra is added to the 16-bit word in GPR Rb and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Add Immediate}{ADDI}
\Iformat{a}{00110}
\Isyntax{ADDI Rd, Ra, \#imm5}{ADDI R5, R3, \#7}
\Ioperation{$Rd \leftarrow Ra + \#imm5$}{C}{V}{5}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Ra is added to the sign-extended 5-bit value given in the instruction and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Add Immediate Byte}{ADDIB}
\Iformat{B}{00011}
\Isyntax{ADDIB Rd, \#imm8}{ADDIB R5, \#93}
\Ioperation{$Rd \leftarrow Rd + \#imm8$}{C}{V}{8}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Rd is added to the sign-extended 8-bit value given in the instruction and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Add Word With Carry}{ADC}
\Iformat{A}{00100}
\Isyntax{ADC Rd, Ra, Rb}{ADC R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra + Rb + C$}{C}{V}{b}{c}{N}{Z}
\Idesc{The 16-bit word in GPR Ra is added to the 16-bit word in GPR Rb with the added carry in set according to the Carry flag from previous operation, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Add Immediate With Carry}{ADCI}
\Iformat{a}{00101}
\Isyntax{ADCI Rd, Ra, \#imm5}{ADCI R5, R4, \#7}
\Ioperation{$Rd \leftarrow Ra + \#imm5 + C$}{C}{V}{5}{c}{N}{Z}
\Idesc{The 16-bit word in GPR Ra is added to the sign-extended 5-bit value given in the instruction with carry in set according to the Carry flag from previous operation, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Negate Word}{NEG}
\Iformat{A}{11010}
\Isyntax{NEG Rd, Ra}{NEG R5, R3}
\Ioperation{$Rd \leftarrow 0 - Ra$}{C}{V}{0}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Ra is added to the 16-bit word in GPR Rb and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Subtract Word}{SUB}
\Iformat{A}{01010}
\Isyntax{SUB Rd, Ra, Rb}{SUB R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra - Rb$}{C}{V}{b}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Rb is subtracted from the 16-bit word in GPR Ra and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Subtract Immediate}{SUBI}
\Iformat{a}{01110}
\Isyntax{SUBI Rd, Ra, \#imm5}{SUBI R5, R3, \#7}
\Ioperation{$Rd \leftarrow Ra - \#imm5$}{C}{V}{5}{0}{N}{Z}
\Idesc{The sign extended 5-bit value given in the instruction is subtracted from the 16-bit word in GPR Ra and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
%
% Instructions 9-16
%
\Imnemonic{Subtract Immediate Byte}{SUBIB}
\Iformat{B}{01011}
\Isyntax{SUBIB Rd, \#imm8}{SUBIB R5, \#93}
\Ioperation{$Rd \leftarrow Rd - \#imm8$}{C}{V}{8}{0}{N}{Z}
\Idesc{The 8-bit immediate value given in the instruction is subtracted from the 16-bit word in GPR Rd and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Subtract Word With Carry}{SUC}
\Iformat{A}{01100}
\Isyntax{SUC Rd, Ra, Rb}{SUC R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra - Rb - C$}{C}{V}{b}{n}{N}{Z}
\Idesc{The 16-bit word in GPR Rb is subtracted from the 16-bit word in GPR Rb with the subtracted carry in set according to the Carry flag from previous operation, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Subtract Immediate With Carry}{SUCI}
\Iformat{a}{01101}
\Isyntax{SUCI Rd, Ra, \#imm5}{SUCI R5, R4, \#7}
\Ioperation{$Rd \leftarrow Ra - \#imm5 - C$}{C}{V}{5}{n}{N}{Z}
\Idesc{The 5-bit immediate value in instruction is subtracted from the 16-bit word in GPR Ra with the subtracted carry in set according to the Carry flag from previous operation, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Compare Word}{CMP}
\Iformat{A}{00111}
\Isyntax{CMP Ra, Rb}{CMP R3, R2}
\Ioperation{$~~~~~~~~~Ra - Rb$}{C}{V}{b}{0}{N}{Z}
\Idesc{The 16-bit word in GPR Rb is subtracted from the 16-bit word in GPR Ra and the status flags are updated without saving the result. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Compare Immediate}{CMPI}
\Iformat{a}{01111}
\Isyntax{CMPI Ra, \#imm5}{CMPI R3, \#7}
\Ioperation{$~~~~~~~~~Ra - \#imm5$}{C}{V}{5}{0}{N}{Z}
\Idesc{The sign extended 5-bit value given in the instruction is subtracted from the 16-bit word in GPR Ra and the status flags are updated without saving the result. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Logical AND}{AND}
\Iformat{A}{10000}
\Isyntax{AND Rd, Ra, Rb}{AND R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra~AND~Rb$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical AND of the 16-bit words in GPRs Ra and Rb is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Logical OR}{OR}
\Iformat{A}{10001}
\Isyntax{OR Rd, Ra, Rb}{OR R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra~OR~Rb$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical OR of the 16-bit words in GPRs Ra and Rb is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Logical XOR}{XOR}
\Iformat{A}{10011}
\Isyntax{XOR Rd, Ra, Rb}{XOR R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra~XOR~Rb$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical XOR of the 16-bit words in GPRs Ra and Rb is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
%
% Instructions 17-24
%
\Imnemonic{Logical NOT}{NOT}
\Iformat{A}{10010}
\Isyntax{NOT Rd, Ra}{NOT R5, R3}
\Ioperation{$Rd \leftarrow NOT~Ra$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical NOT of the 16-bit word in GPR Ra is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Logical NAND}{NAND}
\Iformat{A}{10110}
\Isyntax{NAND Rd, Ra, Rb}{NAND R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra~NAND~Rb$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical NAND of the 16-bit words in GPRs Ra and Rb is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Logical NOR}{NOR}
\Iformat{A}{10111}
\Isyntax{NOR Rd, Ra, Rb}{NOR R5, R3, R2}
\Ioperation{$Rd \leftarrow Ra~NOR~Rb$}{0}{0}{0}{0}{0}{0}
\Idesc{The logical NOR of the 16-bit words in GPRs Ra and Rb is performed and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Register.}
\newpage
\Imnemonic{Logical Shift Left}{LSL}
\Iformat{a}{11111}
\Isyntax{LSL Rd, Ra, \#imm4}{LSL R5, R3, \#7}
\Ioperation{$Rd \leftarrow Ra << \#imm4$}{0}{0}{0}{0}{0}{0}
\Idesc{The 16-bit word in GPR Ra is shifted left by the 4-bit amount specified in the instruction, shifting in zeros, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Logical Shift Right}{LSR}
\Iformat{a}{11101}
\Isyntax{LSR Rd, Ra, \#imm4}{LSR R5, R3, \#7}
\Ioperation{$Rd \leftarrow Ra >> \#imm4$}{0}{0}{0}{0}{0}{0}
\Idesc{The 16-bit word in GPR Ra is shifted right by the 4-bit amount specified in the instruction, shifting in zeros, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Arithmetic Shift Right}{ASR}
\Iformat{a}{11100}
\Isyntax{ASR Rd, Ra, \#imm4}{ASR R5, R3, \#7}
\Ioperation{$Rd \leftarrow Ra >>> \#imm4$}{0}{0}{0}{0}{0}{0}
\Idesc{The 16-bit word in GPR Ra is shifted right by the 4-bit amount specified in the instruction, shifting in the sign bit of Ra, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Load Word}{LDW}
\Iformat{C}{0}
\Isyntax{LDW Rd, [Ra, \#imm5]}{LDW R5, [R3, \#7]}
\Ioperation{$Rd \leftarrow Mem[Ra + \#imm5]$}{0}{0}{0}{0}{0}{0}
\Idesc{Data is loaded from memory at the resultant address from addition of GPR Ra and the 5-bit immediate value specified in the instruction, and the result is placed into GPR Rd. \\\\ The addressing mode of this instruction is Base Plus Offset.}
\newpage
\Imnemonic{Store Word}{STW}
\Iformat{C}{1}
\Isyntax{STW Rd, [Ra, \#imm5]}{STW R5, [R3, \#7]}
\Ioperation{$Mem[Ra + \#imm5] \leftarrow Rd$}{0}{0}{0}{0}{0}{0}
\Idesc{Data in GPR Rd is stored to memory at the resultant address from addition of GPR Ra and the 5-bit immediate value specified in the instruction. \\\\ The addressing mode of this instruction is Base Plus Offset.}
\newpage
%
% Instructions 25-32
%
\Imnemonic{Load Upper Immediate}{LUI}
\Iformat{B}{10100}
\Isyntax{LUI Rd \#imm8}{LUI R5, \#93}
\Ioperation{$Rd \leftarrow \{\#imm8,~0\}$}{0}{0}{0}{0}{0}{0}
\Idesc{The 8-bit immediate value provided in the instruction is loaded into the top half in GPR Rd, setting the bottom half to zero. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Load Lower Immediate}{LLI}
\Iformat{B}{10101}
\Isyntax{LLI Rd \#imm8}{LLI R5, \#93}
\Ioperation{$Rd \leftarrow \{Rd[15:8],~\#imm8\}$}{0}{0}{0}{0}{0}{0}
\Idesc{The 8-bit immediate value provided in the instruction is loaded into the bottom half in GPR Rd, leaving the top half unchanged. \\\\ The addressing mode of this instruction is Register Immediate.}
\newpage
\Imnemonic{Branch Always}{BR}
\Iformat{D}{000}
\Isyntax{BR LABEL}{BR .loop}
\Ioperation{$PC \leftarrow PC + \#imm8$}{0}{0}{0}{0}{0}{0}
\Idesc{Unconditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
\Imnemonic{Branch If Not Equal}{BNE}
\Iformat{D}{110}
\Isyntax{BNE LABEL}{BNE .loop}
\Ioperation{$PC \leftarrow PC + \#imm8~(z==0)?$}{0}{0}{0}{0}{0}{0}
\Idesc{Conditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction if zero status flag (Z) equals zero. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
\Imnemonic{Branch If Equal}{BE}
\Iformat{D}{111}
\Isyntax{BE LABEL}{BE .loop}
\Ioperation{$PC \leftarrow PC + \#imm8~(z==1)?$}{0}{0}{0}{0}{0}{0}
\Idesc{Conditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction if zero status flag (Z) equals one. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
\Imnemonic{Branch If Less Than}{BLT}
\Iformat{D}{100}
\Isyntax{BLT LABEL}{BLT .loop}
\Ioperation{$PC \leftarrow PC + \#imm8~(n\&\sim v~OR~\sim n\&n)?$}{0}{0}{0}{0}{0}{0}
\Idesc{Conditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction if negative status flag and overflow status flag are not equivalent. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
\Imnemonic{Branch If Greater Than Or Equal}{BGE}
\Iformat{D}{101}
\Isyntax{BGE LABEL}{BGE .loop}
\Ioperation{$PC \leftarrow PC + \#imm8~(n\&v~OR~\sim n\&\sim v)?$}{0}{0}{0}{0}{0}{0}
\Idesc{Conditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction if negative status flag and overflow status flag are equivalent. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
\Imnemonic{Branch With Link}{BWL}
\Iformat{D}{011}
\Isyntax{BWL LABEL}{BWL .loop}
\Ioperation{$LR \leftarrow PC + 1;~PC \leftarrow PC + \#imm8$}{0}{0}{0}{0}{0}{0}
\Idesc{Save the current program counter (PC) value plus one to the link register. Then unconditionally branch to the resultant address from addition of PC and the 8-bit immediate value specified in the instruction. LABEL can be both a symbolic name or a numeric value, and is capable of jumping forwards or backwards.\\\\ The addressing mode of this instruction is PC Relative.}
\newpage
%
% Instructions 33-40
%
\Imnemonic{Return}{RET}
\Iformat{D}{010}
\Isyntax{RET}{RET}
\Ioperation{$PC \leftarrow LR$}{0}{0}{0}{0}{0}{0}
\Idesc{Unconditionally branch to the address stored in the link register (LR).\\\\ The addressing mode of this instruction is Register Indirect.}
\newpage
\Imnemonic{Jump}{JMP}
\Iformat{D}{001}
\Isyntax{JMP Ra, \#imm5}{JMP R3, \#7}
\Ioperation{$PC \leftarrow Ra + \#imm5$}{0}{0}{0}{0}{0}{0}
\Idesc{Unconditionally jump to the resultant address from the addition of GPR Ra and the 5-bit immediate value specified in the instruction.\\\\ The addressing mode of this instruction is Base Plus Offset.}
\newpage
\Imnemonic{Push From Stack}{PUSH}
\Iformat{E}{1L0}
\Isyntax[M]{PUSH Ra}{PUSH R3}
\Isyntax[F]{PUSH RL}{PUSH RL}
\Ioperation{$Mem[R7] \leftarrow reg$;~$R7 \leftarrow R7 - 1$}{0}{0}{0}{0}{0}{0}
\Idesc{If `reg' is a general purpose register, store its contents to the stack using the address stored in the stack pointer (R7). If `reg' is the link register, store its contents to the stack using the address stored in the stack point (R7). Then Decrement the stack pointer by one. \\\\The addressing mode of this instruction is Register Indirect Postdecrement.}
\newpage
\Imnemonic{Pop From Stack}{POP}
\Iformat{E}{0L}
\Isyntax[M]{POP Ra}{POP R3}
\Isyntax[F]{POP RL}{POP RL}
\Ioperation{$R7 \leftarrow R7 + 1$;~$Mem[R7] \leftarrow reg$;}{0}{0}{0}{0}{0}{0}
\Idesc{Increment the stack pointer by one. Then if `reg' is a general purpose register, retrieve its contents from the stack using the address stored in the stack pointer (R7). If `reg' is the link register, retrieve its contents from the stack using the address stored in the stack point (R7).  \\\\The addressing modes of this instruction are Register Indirect Preincrement.}
\newpage
\Imnemonic{Return From Interrupt}{RETI}
\Iformat{F}{000}
\Isyntax{RETI}{RETI}
\Ioperation{$PC \leftarrow Mem[R7]$}{0}{0}{0}{0}{0}{0}
\Idesc{Restore program counter to its value before interrupt occured, which is stored on the stack, pointed to be the stack pointer (R7). This must be the last instruction in an interrupt service routine. \\\\ The addressing mode of this instruction is Register Indirect.}
\newpage
\Imnemonic{Enable Interrupts}{ENAI}
\Iformat{F}{001}
\Isyntax{ENAI}{ENAI}
\Ioperation{$IntEnFlag \leftarrow 1$}{0}{0}{0}{0}{0}{0}
\Idesc{Turn on interrupts by setting interrupt enable flag to true (1).}
\newpage
\Imnemonic{Disable Interrupts}{DISI}
\Iformat{F}{010}
\Isyntax{DISI}{DISI}
\Ioperation{$IntEnFlag \leftarrow 0$}{0}{0}{0}{0}{0}{0}
\Idesc{Turn off interrupts by setting interrupt enable flag to false (0).}
\newpage
\Imnemonic{Store Status Flags}{STF}
\Iformat{F}{011}
\Isyntax{STF}{STF}
\Ioperation{$Mem[R7] \leftarrow {12-bit 0, Z, C, V, N}$}{0}{0}{0}{0}{0}{0}
\Idesc{Store contents of status flags to stack using address held in stack pointer (R7). \\\\{\bf CHECK THIS}}
\newpage
%
% Instruction 41
%
\Imnemonic{Load Status Flags}{LDF}
\Iformat{F}{100}
\Isyntax{LDF}{LDF}
\Ioperation{${Z, C, V, N} \leftarrow Mem[R7][3:0]$}{0}{0}{0}{0}{0}{0}
\Idesc{Load content of status flags with lower 4 bits of value retrieved from stack using address held in stack pointer (R7). \\\\{\bf CHECK THIS}}
\newpage